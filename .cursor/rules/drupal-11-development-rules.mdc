
#cache` metadata in render arrays) for pages and blocks, and consider caching data with Drupal’s Cache API for expensive computations. Minimize database queries by loading entities in bulk (e.g. using `EntityQuery` or `::loadMultiple()` instead of inside loops).
- Use the **Batch API** for long-running processes to avoid timeouts, and offload heavy tasks to queued workers (Queue API or Cron tasks) when appropriate. This keeps the web requests fast and responsive.
- Adhere to Drupal’s update mechanisms: do not directly update the database schema in code – use update hooks (`hook_update_N()`) for any database schema changes to ensure they run during updates. Also, never hack core; always apply changes via modules or themes.

**Documentation and Best Practices**
- Write PHPDoc comments for all classes and functions to document their purpose and usage, following Drupal’s documentation standards. This helps maintain clarity for other developers and for the AI.
- Follow Drupal’s official best practices and coding guidelines in any solution. When in doubt, consult the Drupal 11 documentation or example implementations from Drupal core.
- Provide examples or snippets if they help illustrate a solution (for instance, sample code on how to use a certain Drupal service or API). However, ensure any example code is relevant and tested for Drupal 11 compatibility.
- Keep solutions **modular**. For any new functionality, consider if it belongs in a custom module or can be achieved with an existing contributed module. Recommend established contributed modules (from drupal.org) when appropriate, rather than reinventing the wheel in custom code.
